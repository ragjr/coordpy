#
# Created by: R. Allen Gilbert Jr.
#
# Date created: 20160405
#
# Purpose: To process a NED 1/3 arc-second elevation surface for use in an agent-based model that models human movement
# across a snow surface.
#
# Process: The ~10m elevation model is first resampled to 1m cells. Surface roughness is created by adding randomly
# generated values to the existing resampled surface. The user creates a snow surface by adding the desired depth of
# snow to the surface roughness layer and applying a low pass filter to smooth the result. The user creates a depth
# reference layer by subtracting the surface roughness layer from the snow layer. If the underlying surface roughness
# layer is above the snow surface, the value is set to 0 to indicate a depth of 0. This depth surface is exported
# for use in the model. Adjustments are made to the snow surface layer by adding the height of those cells that
# were above the snow during the creation of the depth reference layer. Finally, local slope is calculated and exported
# for use in the model.
############################ Set working directory and load libraries ############################
setwd("C:/Users/Allen/Google Drive/01_Thesis")
library(ggplot2)
library(tidyr)
library(forecast)
library(plyr)
############################ Create datasets ############################
personalUID <- read.csv("./personalUID.csv", header = TRUE)
tracks <- read.csv("./20160401_DryLakes_Survey/dataCombined.csv", header = TRUE)
tracks$uid_person <- as.factor(tracks$uid_person)
transect <- read.csv("./transect.csv", header = TRUE)
# hr.1004 <- read.csv("./20160401_DryLakes_Survey/Data_HeartRate/heartrate_20160401_fattor_clean.csv", header = TRUE)
############################ Rework data frames ############################
tracks.1003 <- tracks[which(tracks$uid_person == "1003"),]
tracks.1003.el <- ts(tracks.1003$elevation, start = min(tracks.1003$id_time), end = max(tracks.1003$id_time))
############################ Interpolation program ############################
test1 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation)
test2 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 2)
test3 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 10)
test4 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 20)
test5 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 50)
test6 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 100)
test7 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 600)
get.spline.info <- function(object)
{
data.frame(x = object$x, y = object$y, df = object$df)
}
splineDF <- ldply(list(test1,test2,test3,test4,test5,test6),get.spline.info)
head(splineDF)
############################ Create graphics ############################
tracks.1003.plot <- ggplot(tracks.1003, aes(x = id_time, y = elevation)) + geom_point()
tracks.1003.plot + geom_line(data = splineDF, aes(x = x, y = y, color = factor(round(df,0)), group = df)) +
scale_color_discrete("Degrees of \nFreedom") +
xlab("Time [Julian]") +
ylab("Elevation [m]")
toPlot <- function(testFile, title)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(title)
}
toPlot(test4, "df 20")
############################ Retreive interpolated data points from the spline model ############################
############################ Include interpolated data points into the base dataset ############################
# ggplot(tracks.1003, aes(x = tracks.1003$uid_object, y = tracks.1003$elevation)) + geom_point(shape = 5)
# with()
# within()
# aggregate()
toPlot <- function(testFile, title)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(title + " Degrees of Freedom")
}
toPlot(test7,"600")
toPlot <- function(testFile, title)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(title) + " Degrees of Freedom"
}
toPlot(test7,"600")
toPlot <- function(testFile, title)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(title & " Degrees of Freedom")
}
toPlot(test7,"600")
toPlot(test7,"600")
toPlot <- function(testFile, title)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(title)
}
toPlot(test7,"600")
splineDF <- ldply(list(test1,test2,test3,test4,test5,test6,test7),get.spline.info)
tracks.1003.plot <- ggplot(tracks.1003, aes(x = id_time, y = elevation)) + geom_point()
tracks.1003.plot + geom_line(data = splineDF, aes(x = x, y = y, color = factor(round(df,0)), group = df)) +
scale_color_discrete("Degrees of \nFreedom") +
xlab("Time [Julian]") +
ylab("Elevation [m]")
head(test7)
tidy(test7)
??forecast
toPlot(test7,"df 600")
write.csv(test7)
as.data.frame.table(test7)
# Title: WR575 GPS Track Records Cleaning
#
# Created by: R. Allen Gilbert Jr.
#
# Date created: 20160405
#
# Purpose: To process a NED 1/3 arc-second elevation surface for use in an agent-based model that models human movement
# across a snow surface.
#
# Process: The ~10m elevation model is first resampled to 1m cells. Surface roughness is created by adding randomly
# generated values to the existing resampled surface. The user creates a snow surface by adding the desired depth of
# snow to the surface roughness layer and applying a low pass filter to smooth the result. The user creates a depth
# reference layer by subtracting the surface roughness layer from the snow layer. If the underlying surface roughness
# layer is above the snow surface, the value is set to 0 to indicate a depth of 0. This depth surface is exported
# for use in the model. Adjustments are made to the snow surface layer by adding the height of those cells that
# were above the snow during the creation of the depth reference layer. Finally, local slope is calculated and exported
# for use in the model.
############################ Set working directory and load libraries ############################
setwd("C:/Users/Allen/Google Drive/01_Thesis")
library(ggplot2)
library(tidyr)
library(forecast)
library(plyr)
############################ Create datasets ############################
personalUID <- read.csv("./personalUID.csv", header = TRUE)
tracks <- read.csv("./20160401_DryLakes_Survey/dataCombined.csv", header = TRUE)
tracks$uid_person <- as.factor(tracks$uid_person)
transect <- read.csv("./transect.csv", header = TRUE)
# hr.1004 <- read.csv("./20160401_DryLakes_Survey/Data_HeartRate/heartrate_20160401_fattor_clean.csv", header = TRUE)
############################ Rework data frames ############################
tracks.1003 <- tracks[which(tracks$uid_person == "1003"),]
tracks.1003.el <- ts(tracks.1003$elevation, start = min(tracks.1003$id_time), end = max(tracks.1003$id_time))
############################ Interpolation program ############################
test1 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation)
test2 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 2)
test3 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 10)
test4 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 20)
test5 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 50)
test6 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 100)
test7 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 600)
get.spline.info <- function(object)
{
data.frame(x = object$x, y = object$y, df = object$df)
}
splineDF <- ldply(list(test1,test2,test3,test4,test5,test6,test7),get.spline.info)
head(splineDF)
############################ Create graphics ############################
tracks.1003.plot <- ggplot(tracks.1003, aes(x = id_time, y = elevation)) + geom_point()
tracks.1003.plot + geom_line(data = splineDF, aes(x = x, y = y, color = factor(round(df,0)), group = df)) +
scale_color_discrete("Degrees of \nFreedom") +
xlab("Time [Julian]") +
ylab("Elevation [m]")
toPlot <- function(testFile, title)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(title)
}
toPlot(test7, "df 600")
############################ Retreive interpolated data points from the spline model ############################
############################ Include interpolated data points into the base dataset ############################
# ggplot(tracks.1003, aes(x = tracks.1003$uid_object, y = tracks.1003$elevation)) + geom_point(shape = 5)
# with()
# within()
# aggregate()
summary(test7.plot)
newData <- within(test7.plot, {})
newData <- within(test7.plot, {
head(test7.plot)
toPlot <- function(testFile, title)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(max(testFile$df))
}
toPlot(test7, "df 600")
toPlot <- function(testFile, title)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(round(max(testFile$df),0))
}
toPlot(test7, "df 600")
test7.plot.ts <- ts(test7.plot$y, start = min(test7.plot$x), end = max(test7.plot$x))
plot(test7.plot.ts)
remove(test7.plot.ts)
toPlot <- function(testFile)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(round(max(testFile$df),0))
}
toPlot(test7)
toPlot(test7)
toPlot <- function(testFile)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(round(max(testFile$df),0))
}
toPlot(test7)
toPlot <- function(testFile)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(round(max(testFile$df),0))
}
toPlot(test7)
# Title: WR575 GPS Track Records Cleaning
#
# Created by: R. Allen Gilbert Jr.
#
# Date created: 20160405
#
# Purpose: To process a NED 1/3 arc-second elevation surface for use in an agent-based model that models human movement
# across a snow surface.
#
# Process: The ~10m elevation model is first resampled to 1m cells. Surface roughness is created by adding randomly
# generated values to the existing resampled surface. The user creates a snow surface by adding the desired depth of
# snow to the surface roughness layer and applying a low pass filter to smooth the result. The user creates a depth
# reference layer by subtracting the surface roughness layer from the snow layer. If the underlying surface roughness
# layer is above the snow surface, the value is set to 0 to indicate a depth of 0. This depth surface is exported
# for use in the model. Adjustments are made to the snow surface layer by adding the height of those cells that
# were above the snow during the creation of the depth reference layer. Finally, local slope is calculated and exported
# for use in the model.
############################ Set working directory and load libraries ############################
setwd("C:/Users/Allen/Google Drive/01_Thesis")
library(ggplot2)
library(tidyr)
library(forecast)
library(plyr)
############################ Create datasets ############################
personalUID <- read.csv("./personalUID.csv", header = TRUE)
tracks <- read.csv("./20160401_DryLakes_Survey/dataCombined.csv", header = TRUE)
tracks$uid_person <- as.factor(tracks$uid_person)
transect <- read.csv("./transect.csv", header = TRUE)
# hr.1004 <- read.csv("./20160401_DryLakes_Survey/Data_HeartRate/heartrate_20160401_fattor_clean.csv", header = TRUE)
############################ Rework data frames ############################
tracks.1003 <- tracks[which(tracks$uid_person == "1003"),]
tracks.1003.el <- ts(tracks.1003$elevation, start = min(tracks.1003$id_time), end = max(tracks.1003$id_time))
############################ Interpolation program ############################
test1 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation)
test2 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 2)
test3 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 10)
test4 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 20)
test5 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 50)
test6 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 100)
test7 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 600)
get.spline.info <- function(object)
{
data.frame(x = object$x, y = object$y, df = object$df)
}
splineDF <- ldply(list(test1,test2,test3,test4,test5,test6,test7),get.spline.info)
head(splineDF)
############################ Create graphics ############################
tracks.1003.plot <- ggplot(tracks.1003, aes(x = id_time, y = elevation)) + geom_point()
tracks.1003.plot + geom_line(data = splineDF, aes(x = x, y = y, color = factor(round(df,0)), group = df)) +
scale_color_discrete("Degrees of \nFreedom") +
xlab("Time [Julian]") +
ylab("Elevation [m]")
toPlot <- function(testFile)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(round(max(testFile$df),0))
}
toPlot(test7)
############################ Retreive interpolated data points from the spline model ############################
############################ Include interpolated data points into the base dataset ############################
# ggplot(tracks.1003, aes(x = tracks.1003$uid_object, y = tracks.1003$elevation)) + geom_point(shape = 5)
# with()
# within()
# aggregate()
summarise(test7.plot)
summarise(test7)
summary(test7.plot)
summary(test7)
head(tracks.1003.el)
plot(tracks.1003.el)
remove(tracks.1003.el)
plot(tracks.1003.plot)
head(test7)
require(plyr)
elBySec <- ddply(tracks.1003, "Second", summarize,
elBySec <- ddply(tracks.1003, "id_time", summarize,
el.mean = mean(elevation), el.sd = sd(elevation),
length = NROW(elevation),
elBySec <- ddply(tracks.1003, "id_time", summarize,
el.mean = mean(elevation), el.sd = sd(elevation),
Length = NROW(elevation),
tfrac = qt(p = .90, df = Length - 1),
Lower = el.mean - tfrac * el.sd / sqrt(Length),
Upper = el.mean + tfrac * el.sd / sqrt(Length))
remove(newData)
elInfo <- summary(test7)
elCoef <- as.data.frame(elInfo$coefficients[,1:2])
library(swirl)
rm(list=ls())
library(swirl)
swirl()
1
swirl()
swirl::install_course_directory()
uninstall_all_courses()
swirl()
swirl()
swirl()
install_from_swirl("Getting and Cleaning Data")
swirl("Getting and Cleaning Data")
# Title: WR575 GPS Track Records Cleaning
#
# Created by: R. Allen Gilbert Jr.
#
# Date created: 20160405
#
# Purpose: To process a NED 1/3 arc-second elevation surface for use in an agent-based model that models human movement
# across a snow surface.
#
# Process: The ~10m elevation model is first resampled to 1m cells. Surface roughness is created by adding randomly
# generated values to the existing resampled surface. The user creates a snow surface by adding the desired depth of
# snow to the surface roughness layer and applying a low pass filter to smooth the result. The user creates a depth
# reference layer by subtracting the surface roughness layer from the snow layer. If the underlying surface roughness
# layer is above the snow surface, the value is set to 0 to indicate a depth of 0. This depth surface is exported
# for use in the model. Adjustments are made to the snow surface layer by adding the height of those cells that
# were above the snow during the creation of the depth reference layer. Finally, local slope is calculated and exported
# for use in the model.
############################ Set working directory and load libraries ############################
setwd("C:/Users/Allen/Google Drive/01_Thesis")
rm(list=ls())
library(ggplot2)
library(tidyr)
library(forecast)
library(plyr)
############################ Create datasets ############################
personalUID <- read.csv("./personalUID.csv", header = TRUE)
tracks <- read.csv("./20160401_DryLakes_Survey/dataCombined.csv", header = TRUE)
tracks$uid_person <- as.factor(tracks$uid_person)
transect <- read.csv("./transect.csv", header = TRUE)
# hr.1004 <- read.csv("./20160401_DryLakes_Survey/Data_HeartRate/heartrate_20160401_fattor_clean.csv", header = TRUE)
############################ Rework data frames ############################
tracks.1003 <- tracks[which(tracks$uid_person == "1003"),]
tracks.1003.el <- ts(tracks.1003$elevation, start = min(tracks.1003$id_time), end = max(tracks.1003$id_time))
############################ Interpolation program ############################
test1 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation)
test2 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 2)
test3 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 10)
test4 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 20)
test5 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 50)
test6 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 100)
test7 <- smooth.spline(x = tracks.1003$id_time, y = tracks.1003$elevation, df = 600) # 600 df written however, the max is 127 and the program defaults to that.
get.spline.info <- function(object)
{
data.frame(x = object$x, y = object$y, df = object$df)
}
splineDF <- ldply(list(test1,test2,test3,test4,test5,test6,test7),get.spline.info)
head(splineDF)
############################ Create graphics ############################
tracks.1003.plot <- ggplot(tracks.1003, aes(x = id_time, y = elevation)) + geom_point()
tracks.1003.plot + geom_line(data = splineDF, aes(x = x, y = y, color = factor(round(df,0)), group = df)) +
scale_color_discrete("Degrees of \nFreedom") +
xlab("Time [Julian]") +
ylab("Elevation [m]")
toPlot <- function(testFile)
{
testFile.plot <- get.spline.info(testFile)
tracks.1003.plot + geom_line(data = testFile.plot, aes(x = x, y = y)) +
xlab("Time [Julian]") +
ylab("Elevation [m]") +
ggtitle(round(max(testFile$df),0))
}
toPlot(test7)
############################ Retreive interpolated data points from the spline model ############################
# How can I take modeled data that used a spline interpolation technique and transform it into a data frame?
elBySec <- ddply(tracks.1003, "id_time", summarize,
el.mean = mean(elevation), el.sd = sd(elevation),
Length = NROW(elevation),
tfrac = qt(p = .90, df = Length - 1),
Lower = el.mean - tfrac * el.sd / sqrt(Length),
Upper = el.mean + tfrac * el.sd / sqrt(Length)
)
elInfo <- summary(test7)
elCoef <- as.data.frame(elInfo$coefficients[,1:2])
############################ Include interpolated data points into the base dataset ############################
# with()
# within()
# aggregate()
# Title: WR575 GPS Track Records Cleaning
#
# Created by: R. Allen Gilbert Jr.
#
# Date created: 20160405
#
# Purpose: To process a NED 1/3 arc-second elevation surface for use in an agent-based model that models human movement
# across a snow surface.
#
# Process: The ~10m elevation model is first resampled to 1m cells. Surface roughness is created by adding randomly
# generated values to the existing resampled surface. The user creates a snow surface by adding the desired depth of
# snow to the surface roughness layer and applying a low pass filter to smooth the result. The user creates a depth
# reference layer by subtracting the surface roughness layer from the snow layer. If the underlying surface roughness
# layer is above the snow surface, the value is set to 0 to indicate a depth of 0. This depth surface is exported
# for use in the model. Adjustments are made to the snow surface layer by adding the height of those cells that
# were above the snow during the creation of the depth reference layer. Finally, local slope is calculated and exported
# for use in the model.
############################ Set working directory and load libraries ############################
setwd("C:/Users/Allen/Google Drive/01_Thesis")
rm(list=ls())
library(ggplot2)
library(tidyr)
library(forecast)
library(plyr)
############################ Create metadatasets ############################
personalUID <- read.csv("./personalUID.csv", header = TRUE)
transect <- read.csv("./transect.csv", header = TRUE)
phoneMeta <- read.csv("./phoneMeta.csv", header = TRUE)
appMeta <- read.csv("./appMeta.csv", header = TRUE)
############################ Create datasets ############################
tracksDL <- read.csv("./20160401_DryLakes_Survey/Tracks_20160401_DryLakes.csv", header = TRUE)
tracksDL$uid_person <- as.factor(tracksDL$uid_person)
heartDL <- read.csv("./20160401_DryLakes_Survey/HeartRate_20160401_DryLakes.csv", header = TRUE)
heartDL$uid_person <- as.factor(heartDL$uid_person)
surveyDL <- read.csv("./20160401_DryLakes_Survey/WR575_S2016_Dry_Lake_SNOTEL_snow_depth.csb",header = TRUE)
tracksJW <- read.csv("./20160430_JoeWright_Survey/Tracks_20160430_JoeWright.csv", header = TRUE)
tracksJW$uid_person <- as.factor(tracksJW$uid_person)
heartJW <- read.csv("./20160430_JoeWright_Survey/HeartRate_20160430_JoeWright.csv", header = TRUE)
heartJW$uid_person <- as.factor(heartJW$uid_person)
############################ Rework data frames ############################
tracks.1003 <- tracks[which(tracks$uid_person == "1003"),]
tracks.1003.el <- ts(tracks.1003$elevation, start = min(tracks.1003$id_time), end = max(tracks.1003$id_time))
surveyDL <- read.csv("./20160401_DryLakes_Survey/WR575_S2016_Dry_Lake_SNOTEL_snow_depth.csv",header = TRUE)
View(surveyDL)
View(phoneMeta)
View(personalUID)
View(appMeta)
View(heartDL)
View(surveyDL)
ggplot(tracksDL, aes(x = id_time, y = elevation))
ggplot(tracksDL, aes(x = id_time, y = elevation)) + facet_wrap(~uid_person) + geom_line()
View(tracksDL)
ggplot(tracksDL, aes(x = utm_east, y = utm_north)) + facet_wrap(~uid_person) + geom_line()
View(personalUID)
summary(tracksDL$elevation)
personalUID <- read.csv("./metaPersonalUID.csv", header = TRUE)
transect <- read.csv("./metaTransectAssignment.csv", header = TRUE)
phoneMeta <- read.csv("./metaPhone.csv", header = TRUE)
appMeta <- read.csv("./metaApplication.csv", header = TRUE)
heartJW <- read.csv("./20160430_JoeWright_Survey/HeartRate_20160430_JoeWright.csv", header = TRUE)
heartJW$uid_person <- as.factor(heartJW$uid_person)
heartDL <- read.csv("./20160401_DryLakes_Survey/HeartRate_20160401_DryLakes.csv", header = TRUE)
heartDL$uid_person <- as.factor(heartDL$uid_person)
View(heartDL)
ggplot(heartDL[which(uid_person = 1002)], aes(x = id_time, y = heartDL$exertion)) + facet_wrap(~uid_person) + geom_line()
ggplot(heartDL[which(uid_person = "1002")], aes(x = id_time, y = heartDL$exertion)) + facet_wrap(~uid_person) + geom_line()
ggplot(heartDL[uid_person == "1002"], aes(x = id_time, y = heartDL$exertion)) + facet_wrap(~uid_person) + geom_line()
ggplot(heartDL[which(uid_person == "1002")], aes(x = id_time, y = heartDL$exertion)) + facet_wrap(~uid_person) + geom_line()
ggplot(heartDL[which(heartDL$uid_person == "1002")], aes(x = id_time, y = heartDL$exertion)) + facet_wrap(~uid_person) + geom_line()
ggplot(heartDL[which(heartDL$uid_person == "1002")], aes(x = id_time, y = heartDL$exertion)) + geom_line()
View(heartDL)
ggplot(heartDL[which(heartDL$uid_person == "1004")], aes(x = id_time, y = heartDL$exertion)) + geom_line()
ggplot(heartDL[which(heartDL$uid_person == "1004")], aes(x = heartDL$id_time, y = heartDL$exertion)) + geom_line()
ggplot(heartDL, aes(x = ~id_time, y = ~exertion)) + facet_wrap(~uid_person) + geom_line()
ggplot(heartDL, aes(x = id_time, y = exertion)) + facet_wrap(~uid_person) + geom_line()
ggplot(heartDL[which(heartDL$uid_person == "1004")], aes(x = id_time, y = exertion)) + geom_line()
ggplot(heartDL[which(heartDL$uid_person == "1006")], aes(x = id_time, y = exertion)) + geom_line()
head(tracksDL[which(uid_person == "1004")])
head(tracksDL[which(tracksDL$uid_person == "1004")])
head(tracksDL[$uid_person == "1004"])
head(tracksDL[~uid_person == "1004"])
head(tracksDL$uid_person[1004])
ggplot(heartDL[which(heartDL$uid_person == "1006"),], aes(x = id_time, y = exertion)) + geom_line()
ggplot(heartDL[which(heartDL$uid_person == "1006"),], aes(x = id_time, y = exertion)) + geom_line(alpha(alpha = 50))
ggplot(heartDL[which(heartDL$uid_person == "1006"),], aes(x = id_time, y = exertion)) + geom_line(alpha(alpha = .5))
ggplot(heartDL[which(heartDL$uid_person == "1006"),], aes(x = id_time, y = exertion)) + geom_line(alpha(alpha = 5))
ggplot(heartDL[which(heartDL$uid_person == "1006"),], aes(x = id_time, y = exertion)) + geom_line(alpha(5))
ggplot(heartDL[which(heartDL$uid_person == "1006"),], aes(x = id_time, y = exertion)) + geom_line(alpha = 0.5)
ggplot(heartDL[which(heartDL$uid_person == "1006"),], aes(x = id_time, y = exertion))
+ geom_line(alpha = 0.5)
+ geom_line(data = tracksDL, aes(x = tracksDL$id_time, y = tracksDL$elevation))
ggplot(heartDL[which(heartDL$uid_person == "1006"),], aes(x = id_time, y = exertion))
+ geom_line(alpha = 0.5)
+ geom_line(data = tracksDL$elevation)
ggplot(heartDL[which(heartDL$uid_person == "1006"),], aes(x = id_time, y = exertion))
+ geom_line(alpha = 0.5)
+ geom_line(data = as.factor(tracksDL$elevation))
